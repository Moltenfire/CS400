THEORY ProofList IS
  _f(1) & isitprime.29,(_f(36) & _f(34) => _f(35));
  _f(1) & isitprime.28,(_f(33) & _f(34) => _f(35));
  _f(1) & isitprime.27,(_f(12) & _f(3) => _f(32));
  _f(1) & isitprime.26,(_f(12) & _f(3) => _f(31));
  _f(1) & isitprime.25,(_f(12) & _f(3) => _f(30));
  _f(1) & isitprime.24,(_f(12) & _f(3) => _f(29));
  _f(1) & isitprime.23,(_f(12) & _f(3) => _f(28));
  _f(1) & isitprime.22,(_f(12) & _f(3) => _f(27));
  _f(1) & isitprime.21,(_f(12) & _f(3) => _f(26));
  _f(1) & isitprime.20,(_f(12) & _f(3) => _f(25));
  _f(1) & isitprime.19,(_f(12) & _f(3) => _f(24));
  _f(1) & isitprime.18,(_f(12) & _f(3) => _f(23));
  _f(1) & isitprime.17,(_f(12) & _f(3) => _f(22));
  _f(1) & isitprime.16,(_f(12) & _f(3) => _f(21));
  _f(1) & isitprime.15,(_f(12) & _f(3) => _f(20));
  _f(1) & isitprime.14,(_f(12) & _f(3) => _f(19));
  _f(1) & isitprime.13,(_f(12) & _f(3) => _f(18));
  _f(1) & isitprime.12,(_f(12) & _f(3) => _f(17));
  _f(1) & isitprime.11,(_f(12) & _f(3) => _f(16));
  _f(1) & isitprime.10,(_f(12) & _f(3) => _f(15));
  _f(1) & isitprime.9,(_f(12) & _f(3) => _f(14));
  _f(1) & isitprime.8,(_f(12) & _f(3) => _f(13));
  _f(1) & isitprime.7,(_f(9) & _f(3) => _f(11));
  _f(1) & isitprime.6,(_f(9) & _f(3) => _f(10));
  _f(1) & isitprime.5,(_f(2) & _f(3) => _f(8));
  _f(1) & isitprime.4,(_f(2) & _f(3) => _f(7));
  _f(1) & isitprime.3,(_f(2) & _f(3) => _f(6));
  _f(1) & isitprime.2,(_f(2) & _f(3) => _f(5));
  _f(1) & isitprime.1,(_f(2) & _f(3) => _f(4))
END
&
THEORY Formulas IS
  ("`isitprime preconditions in previous components'" & nn: INTEGER & 0<=nn & nn<=2147483647 & not(nn = 0));
  ("`isitprime preconditions in this component'" & nn: INTEGER & 0<=nn & nn<=2147483647 & not(nn = 0));
  "`Check preconditions of called operation, or While loop construction, or Assert predicates'";
  (nn-1: INTEGER);
  (nn-1<=2147483647);
  (-2147483647<=nn-1);
  (-2147483647<=nn);
  (1 = SIGMA(yy).(yy: 1..1 | nn mod yy));
  ("`isitprime preconditions in this component'" & nn: INTEGER & 0<=nn & nn<=2147483647 & not(nn = 0) & "`Local hypotheses'" & div$0 = SIGMA(yy).(yy: 1..xx$0 | nn mod yy));
  (nn-xx$0: INTEGER);
  (0<=nn-xx$0);
  ("`isitprime preconditions in this component'" & nn: INTEGER & 0<=nn & nn<=2147483647 & not(nn = 0) & "`Local hypotheses'" & div$0 = SIGMA(yy).(yy: 1..xx$0 | nn mod yy) & not(xx$0 = nn-1) & xx$0 = div$0);
  (xx$0+1: INTEGER);
  (xx$0+1<=2147483647);
  (-2147483647<=xx$0+1);
  (xx$0: INTEGER);
  (xx$0<=2147483647);
  (-2147483647<=xx$0);
  (div$0+nn mod (xx$0+1): INTEGER);
  (div$0+nn mod (xx$0+1)<=2147483647);
  (-2147483647<=div$0+nn mod (xx$0+1));
  (nn mod (xx$0+1): INTEGER);
  (0<=nn mod (xx$0+1));
  (nn mod (xx$0+1)<=2147483647);
  (0<=xx$0+1);
  (not(xx$0+1 = 0));
  (div$0: INTEGER);
  (div$0<=2147483647);
  (-2147483647<=div$0);
  (-2147483647<=nn mod (xx$0+1));
  (nn-(xx$0+1)+1<=nn-xx$0);
  (div$0+nn mod (xx$0+1) = SIGMA(yy).(yy: 1..xx$0+1 | nn mod yy));
  ("`isitprime preconditions in this component'" & nn: INTEGER & 0<=nn & nn<=2147483647 & not(nn = 0) & "`Local hypotheses'" & not(not(xx$7777 = nn-1) & xx$7777 = SIGMA(yy).(yy: 1..xx$7777 | nn mod yy)) & SIGMA(yy).(yy: 1..xx$7777 | nn mod yy) = 1 & not(!xx.(xx: INTEGER & 0<=xx & xx<=2147483647 & xx: 2..nn-1 => not(nn mod xx = 0))));
  "`Check that the invariant (oo$1 = oo) is preserved by the operation - ref 4.4, 5.5'";
  (bfalse);
  ("`isitprime preconditions in this component'" & nn: INTEGER & 0<=nn & nn<=2147483647 & not(nn = 0) & "`Local hypotheses'" & not(not(xx$7777 = nn-1) & xx$7777 = SIGMA(yy).(yy: 1..xx$7777 | nn mod yy)) & not(SIGMA(yy).(yy: 1..xx$7777 | nn mod yy) = 1) & !xx.(xx: INTEGER & 0<=xx & xx<=2147483647 & xx: 2..nn-1 => not(nn mod xx = 0)))
END
&
THEORY EnumerateX 
END
&
THEORY Version IS
  POVersion(V3.8.3)(CLT == "V3.7.6")(genOPO == KO, genDivergencePO == KO, local_op == OK)
END
